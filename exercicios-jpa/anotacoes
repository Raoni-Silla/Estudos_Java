Java Persistence Api
é um padrão de persistencia chamado data mapper, e orm, dois paradigmas agrupados
do mundo relacional, modelo e/r, e temos outro paradigma de oo e como esses dois
mundos se conectam, é o papel que o data mapper tem com o orm

padrão

Data mapper vs active record

basicamente nas lgp temos o poo, de um lado temos o poo e do outro a uma tabela
com colunas, chaves e restrições, os relacionamentos são feitos entre tabelas e etc

basicamente o active record é muito encontrado em frameworks do php laravel
eloquent, no ruby
vou criar um obj chamado cliente
e o cliente tem atributos e comportamentos
ele tem uma relação com a table clientes do bd

então eu tenho uma serie de atributos que vão estar relacionados com a coluna
do bd, qnd eu tenho um padrão active record, o proprio objeto tem dentro dele todos
os metodos necessarios para se persisitir, um registro ativo, o proprio objeto tem os metodos
necessarios para se inserir no bd, isso é feito por herança+

Cliente c = new Cliente;
c.save(); <- metodo dentro de cliente que salva o cliente no bd

muitas vezes de acessar só o obejto posso acessar o nome da classe
Cliente.find();
metodo estatico que pertence a classe, pq pra buscar clientes em uma tabela no bd
eu n busco apartir de uma instancia, e sim em um bd
a classe representasse a tabela e o objeto uma linha do bd

proprio objeto responsavel por interagir com a camada de persistencia
isso é active record

pesquisar sobre active record em cima do framework rubyonrails

ja o data mapper é o padrão utilizado pelo jpa

do lado eu tenho um obj1,obj2,obj3

e tenho uma tabela1,tabela2,tabela 3
a ideia é usar um tipo de mecanismo xml, json, anotation
fazer um mapeamento entre um atributo do objeto e uma coluna do bd
eu pego o proprio objeto e faço o mapeamento dele pra uma tabela


eu tenho uma classe pŕoduto, que eu tenho que dizer que essa classe ta mapeado pra tabela x
e mapeo cada atributo pra cada coluna

dentro do jpa tenho o @table(passo o nome da tabela)
a classe agora ta mapeada para a tabela do banco de dados

tenho um objeto e tenho uma tabela, esse obj precisa ser mapeado pra tabela
com algum tipo de informação
e dentro do objeto eu tenho atributos
e esses atributos são mapeados para as colunas da tabela

@table
@Id digo que determinado atributo é a chave primaria da tabela
@Column esse atributo aponta pra uma determinada coluna
preciso fazer esse orm, object relaction mapper


reunir formas de se fazer relacionametos do mundo oo e relacional

relacionamentos
temos dois lados
da parte de oo e do outro lado pela e/r

temos duas tabela com linhas e colunas
como é feito relacionamento?
temos dentro de uma tabela um conceito de pk
essa pk vai pra outra tabela gerando uma fk, um pra muitos
tenho um id 1 e posso ter varias linhas na outra tabela que terao relacionameto com id 1

a relação um pra um tem a mesma estrutura mas na outra tabela temos um filtro que diz
que nao aceita repetição, sendo unique

agora muitos pra muitos
criamos uma tabela intermediaria
agora a chave primaria da tabela que une as duas, vai ser uma tupla das chaves estrangeiras
que estão conectadas nessa tabela

em e/r não existe relações bidirecionais
ou seja eu n pego a chave de uma tabela x e coloco em y, e a de y em x
é sempre unidirecional

é mais facil achar os recursos na tabela que recebe a a pk cm fk

ja olhando apenas pra tabela que a pk vem, n da pra dizer quantos registros estao
relacionados com a outra tabela


no mundo oo temos as 3 relações de forma fisica

Classe A -> Classe B de um pra um, dentro de b tem um atributo de classe A
e se quiser ser bidirecional,dentro da classe a posso ter um atributo de tipo b
o mais comum é ter uma relação unidirecional

do ponto de vista relacional, a informação do relacionamento esta sempre do lado n

class b {
A atributo;relação um pra n, b = n e a = um
}de forma bidirecional posso criar uma list na class a do tipo b

e se fosse n pra m?

dentro de a tenho uma lista <b> e do lado de b tenho um list <a>
uma relação bidirecional muito pra muitos

as relações bidirecionais podem ser inconsistentes
quando fizer uma relação assim é preciso garantir a consistencia dos dados


Jpa
@OneToOne
@OneToMany apartir do lado um quero relacionar uma lista do lado muitos, dentro da mae aponto pro filho
@ManyToOne é o par da relação de cima, dentro do filho aponto pra mae
@ManyToMany


28/10/25 <-- revisando conceitos

revisando conceitos, temos dois padrões de persistencia

data mapper vs active record

de um lado temos a poo e do outro lado uma tabela do banco de dados
o active record é encontrado em php, como laravel, eloquent, ruby on rails
vou criar um object chamado cliente, e o cliente tem uma serie de atributos e comportamentos
e esse cliente tem relação com a tb cliente do banco de dados
temos uma serie de atributos relacionados com o banco de dados

tenho uma serie de atributos que se relacionam com a coluna do banco de dados
cada atributo é uma coluna

quando se tem um padrão active record, o proprio objeto que se relaciona com o banco de dados
vai ter todos os metodos necessarios para se persisitir, o proprio objeto tem os metodos necessarios
para se inserir no banco de dados

se eu criar um cliente c, vou ter um metodo dentro de cliente que vai salvaer esse objeto no bd
c.save();
c.remove();

Cliente.find(select no banco de dados)
porque pra buscar cliente dentro de uma tabela no banco de dados
n se busca apartir de uma unica instancia e sim da tabela

classe = tabela
objeto = linha do banco de dados

isso é de acordo com o active records
entao ele guarda metodos dentro da propria class/objeto para se persistir sozinho no banco de dados
porque temos o proprio objeto responsavel com todos os metodos pra interagir com a camada de persistencia

o data mapper é utilizado pelo jpa

de um lado tenho um obj 1, obj 2, e pra cada objeto tenho uma tabela
e a ideia aqui é usar algum tipo de mecanismo para mapear o atributo do objeto
e uma coluna do banco de dados

antes de fazer isso pego o proprio objeto dele e faço o mapeamento dele pra uma tabela
obj 1 se relaciona com a objtb1
entao cada atributo é mapeado como uma coluna do banco de dados

data acess object eventualmente vamos acabar precisando dele pra fazer a persistencia dos dados
##orm mapeamento objeto relacional

orm
object relational mapper
mapeamento de objeto relacional

é um conceito importante pro jpa

defino uma classe produto
produto
nome
preço
qntd

entao de um lado temos o produto em oo e do outro lado tenho uma tabela em e/r

como eu mapeio uma classe pra uma tabela, pra fazer isso uso o conceito de anotation

usamos anotation pra dizer pro jpa

temos uma anotação @Table(nome da tabela)
significa que essa classe esta sendo mapeada pra tabela do banco de dados
table (produtos)
produto
nome
preco
qntd

a classe acima agora esta relacionada com uma tabela, e o framework entende que essa classe
esta relacionada com a tabela
@Id determina a chave primaria do banco de dados
@Column determina o nome da coluna e aponta pra coluna

dependendo de como o jpa é configurado ele pode criar automaticamente uma tabela pra gente no bd
se uma coluna é not null ou nao, vai ser util na hora que eu for criar as tabelas, qnd eu for mapear as tabelas
esse not null nao vai validar os dados

algumas dessas informações colocadas no orm serve pra criar as tabelas e outras servem pra todos os momentos
essa classe aponta pra tabela com esse nome

oque é persistencia ?
Na computação, persistência de dados é a capacidade de guardar informações de forma permanente,
para que elas não se percam quando o sistema é fechado.

o persistence unit serve pra gente conectar nos banco de dados, no momento que eu for
interagir com o jpa tenho que dizer qual é a unidade de persistencia que ele vai conectar
isso vai ser definido na persitence unit, definindo o nome da persistencia

Persistência: É o conceito de salvar dados de objetos em um banco.

Unidade de Persistência: É o conjunto de configurações nomeado
(ex: name="meu-banco-principal") que diz ao seu programa como,
onde e o quê persistir.
Ela responde a todas estas perguntas:

O QUÊ? Quais classes Java (Entidades) eu devo gerenciar?

(Ex: Usuario.class, Produto.class, Pedido.class)

ONDE? Para qual banco de dados eu devo enviar esses dados?

(Ex: A URL jdbc:mysql://localhost:3306/meu_banco)

COMO (Credenciais)? Como eu me autentico nesse banco?

(Ex: Usuário root e Senha 123456)

QUEM (Faz o trabalho)? Qual "motor" (Provedor) eu devo usar para fazer a tradução?

(Ex: O HibernatePersistenceProvider)

COMO (Tradução)? Em qual "dialeto" SQL eu devo falar com esse banco?

(Ex: MySQL8Dialect, porque falar com MySQL é diferente de falar com PostgreSQL)

QUAIS REGRAS? O que eu devo fazer com as tabelas quando o programa iniciar?

(Ex: hibernate.hbm2ddl.auto = update -> "Verifique se as tabelas existem e as atualize se necessário.")

temos que colocar as classes mapeadas

depois informamos as propriedades do banco de dados
criando uma serie de propertie que vai ter nome e valor
definindo um usuario e uma senha

pra inserir elementos no banco de dados (insert)
se usa o persist em contexto de transação, da um transação begin
e faz oque tem que ser feito
depois commita a transação

o @generatedvalue diz que o atributo é autoincremento
temos estrategias de geração temos o auto, identity, sequence, table
uma sequence pode ser compartilhada com outras entidades
o identity garante que cada entidade vai ter sua propria sequencia de id

o sequence pode compartilhar uma mesma sequencia com outras entidades


relacionamentos
um pra um
a primeira pergunta que eu tenho que fazer, é mais comum eu obter um cliente apartir do assento
ou o assento apartir do cliente, isso define aonde nosso atributo de ligação vai ficar

eu primeiro tenho que inserir o lado da relação que nao tem a chave estrangeira na relação um pra um

preciso colocar um cascade pra persistir um cliente com persist, eu posso infromar com o cascade quais
operções em cascata vao ser permitidads com aquela ligação

atençao com o cascade pq ele executa diversas operações em cascata, nem sempre é bom utilizar

então temos que nos perguntas se apartir de x é mais facil obter y, ou apartir de y é mais facil obter x
entao aqui temos que apartir do cliente, é mais facil obter o assento

entao o cliente aqui quem vai ter o atributo do tipo assento

se eu tentar inserir o cliente primeiro que o assento em duas transações diferentes, o java vai dar erro
pois precisa ser persistido em ordem correta no banco de dados