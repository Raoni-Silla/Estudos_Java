DateTimeFormatter
DateTimeFormatter formatador = DateTimeFormatter.ofPattern("dd/MM/yyyy");
ele ensina o date parse, como ele vai formatar a data que vem em forma de
string pra ele
o date parse, ele entende por padrao d-m-a, e nao d/m/a
então eu crio um formatador que vai formatar a data, e passo ele
como parametro tbm na mudança de string pra local date
pro java ver o formato e entender como deve formatar as datas

DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy");
LocalDate nascimento = LocalDate.parse(aluno.getDataNascimento(), formatter);
Integer idade = Period.between(nascimento, LocalDate.now()).getYears();

o period between calcula o tempo entre duas datas
ali eu passo a variavel nascimento, que guarda a data de nascimento do user
e depois digo pra ele pegar a data atual, ele calcula o tempo e depois pega apenas
os anos de diferença

IntStream.range(0, listaAlunos.size())
o IntStream.range (onde começa, onde termina)
ele pega desde o indice 0 até o tamanho final da minha lista
e pra cada iteração ele implementa um lambda no foreach

return ChronoUnit.YEARS.between(data, LocalDate.now()) > 30;
optei pelo uso do ChronoUnit em vez do periodBetween, porque ele é mais preciso
ele conta os dias e os anos para comparar, e não apenas os anos, ele retorna os valores
de forma mais direta, o period between quebra o periodo em dias, meses e anos
é pra quando quero algo com mais precisão, agora o chrono unit vai me retornar apenas
o numero de anos exatos que eu pedi