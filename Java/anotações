Revisão do conteudo 04 setembro, 2025

ontem estudei sobre java, a introdução da linguagem java, coisas basicas sobre como
oque é um algoritimo, que na minha explicação atraves do meu entendimento seria, passos a passos que voce usa para a resolução
de um problema, podendo ter passos que só acontecem se outra condição acontecer, ou passos que se repetem até determinada situa
ção for atingida

então um algoritimo recebe entradas, as entradas vão para o processamento (algoritimo), dali gera um dado de saida
esse é o tipo mais comum de algoritimo visto, porem existe algoritimos que só recebem entrada mas não tem saida apos
processamento(algoritimo), tem aqueles que só tem saida, e aqueles que são mais esquisitos ainda que nao possuem entada
nem saida de dados

#Estrutura de dados
uma estrutura de dados serve para organizar e admnistrar os dados
podendo ser um exemplo de estrutura de dados
--listas (ordenadas ou não ordenadas)
--filas (FIFO)
--pilhas (LIFO)
--arvore
--int, real char, variaveis e constates e operação

#TERMINAL
um terminal é uma forma de conversar com o So de forma direta atraves de linhas de comandos
um terminal quando aberto ele sempre vai apontar para a pasta raiz da sua maquina
como meu exemplo raoni@PcRaoni:~$
o comando LS, lista os arquivos que estão na pasta apontada pelo terminal no momento
o comando PWD(print work directory) printa o caminho de pastas para o diretorio que voce esta agora
LS -A mostra todos os arquivos escondidos
LS -L mostra a versão longa do ls normal, trazendo mais informações
podendo juntar as duas LS -AL
cd (change directory) muda o diretorio atual da maquina
clear limpa o terminal
mkdir cria uma pasta nova
RMDIR remove as pastas
rm remove arquivos

#FUNDAMENTOS
src -> source, fonte, pasta raiz do codigo java, onde vai ficar guardado os pacotes e as classes
package -> um pacote que agrupa e organiza as suas classes de função parecida em java
como por exemplo se tivessemos um projeto chamado clinica
teriamos um package de pessoas por exemplo
dentro dele teriamos a seguinte ordem package pessoas > medico.java, paciente.java, atendente.java
todas são class do nosso arquvio java, ficariam dentro dos packages organizados por funções parecidas
#TIPOS PRIMITIVOS
Inteiros:
Short
Byte
Long
Int
reais:
Float
Double

char -> 1 caracteres
boolean -> false or true
------------------------------
hoje sexta, setembro 5, 2025

Import:
12:00:
 o import traz bibliotecas de fora, como se fossem peças de um carro novo
 java ja vem com tudo padrão pra rolar e ser executado, se vocẽ precisar de coisas a mais
 voce precisa importar bibliotecas, voce só pode usar a data, importando a biblioteca util e date, pois nao vem
 como bibliotecas padrões da linguagem
 #Strings:
 13:00 uma string é uma forma mais maleavel de se manusear frases em java, tendo varios metodos
 pra utilizar nela como .lenght() que diz o tamamnho daquela string, ou um metodo endwith que verifica se a ultima palavra
 é oque voce colocar nos parenteses como criterio, o starts with funciona da mesma forma so que com o começo
 a frase termina com tal palavra, uso o end with, tem o indexof que vai te dizer em qual indice do vetor se encontra o começo da palavra que voce passar pra ele
 substring que quebra a string pegando um indice de inicio e de fim, pra te retornar partes dela

ler e imprimir dados do usuario 13:30:

usa-se o Scanner para ler dados

Scanner nome_do_scanner = new Scanner (tipo de leitura que ele fara);
no caso seria Scanner cin = new Scanner (System.in); o System.in diz que ele fara a leitura da entrada de dados atraves do teclado
lembrar sempre de fechar o scanner pra economizar recursos com nome_do_scanner.close

pra imprimir podemos ter algumas formas
System.out.println("quebra a linha");
System.out.printf("melhor pra se imprimir strings de forma formatada")
%d para inteiros, %f para reais e %s para string, o %f da pra ajustar as casas decimais que o numero tera no output pro console
como %.2f;

14:26: Primitivos vs objetos:
a string é uma classe assim como primitivovsobjeto tbm é

no momento que vc cria um valor pra uma classe, nos dizemos que esse valor criado para classe é um objeto, tendo atributos e comportamentos
comportamento do objeto string que foi criado com valor texto

voce nao tem nenhum comportamento associado a um tipo primitivo
o tipo primitivo só carrega dentro dele um valor
mas se eu precisar que um valor numerico tenha um comportamento associado
ai se usa wrappers, aquilo que envolve, versao objeto dos tipos primitivos. e pra cada tipo tem wrappers
tudo em java é baseado em classes com exceções de tipos primitivos
todoquando vc cria objetos de uma determinada classes nele vai ter comportamentos e atributos

wrapper é uma classe que dentro dela tem um tipo primitivo,q quando voce envolve um tipo primitico com wrapper
esse tipo passa a ter comportamentos de um objeto, podendo usar a notação ponto pra acessar certos comportamentos
pra cada versão do tipo primitivo tem uma versão orientada a objetos com comportametnos e atributos


conversão de tipos primitivos

byte>shorte>int>long -> convertendo assim voce não perde informações, do menor pro maior
long>int>short>byte -> assim voce tem que dar uma permissão explicita pro java

float > inteiro -> voce perde informações apos a virgula, agora ao contrario não tem problema de int > float
as conversões forçadas são explicitas e as não forçadas são implicitas, java nao analisa valor e sim o tipo


-------------------------------------
Hoje Segunda, setembro 8, 2025 10:24:

Conversão de string pra tipos numericos e vice e versa:
Double.parseDouble(vl1); converte de string para numero, tem que tomar cuidado com a perca de alguns dados
ystem.out.println(n1.toString().length()); o integer tranforma apartir de metodos para string
System.out.println(Integer.toString(n2));

operadores em java 11:50:
unarios, binarios e ternarios

a soma é um operador binario por exemplo, pois precisamos de um valor antes e depois
aritmeticos
sao todos como +,-,/,% e todos outros que retornem calculos matematicos
relacionais
logicos
atribuição
quanto o operador vem antes do operando é prefix ++a
quando vem apos do operando é postfix a++
e quando o operando estiver no meio de dois operandos se usa infix 3 + 2

na comparação de string se usa equals, e trim para tirar os espaços em branco, e equals para comparar o conteudo da string
sempre comparar qualquer objeto com equals para comparar o valor e nao ==, porque pra objetos em java o == confere se esses objetos
estao guardados no mesmo lugar da memoria

13:30desafio calculadora concluida

14:42:
jre vs jdk

jre java runtime enviroment, é uma aplicação java que voce precisa ter no seu dispositivo para usar java em sua maquina, pois ele instala uma jvm na sua maquina
essa jvm le o arquivo que foi compilado pelo javac.class(bytecode) que é enviado para ela e retorna um arquivo.exe pro seu So

ja a jdk java development kit, é um kit de desenvolvimento java, ele vem com coisas muito uteis para o desenvolvedor java

estruturas de repetições 15:38:
o laço ideal para se usar quanto se tem algo determinado pra quando acabar é o for
e pra quando for indeterminado é melhor se usar o while
ja o do while, o do executa primeiro e o while depois testa a condição pra executar denovo, mas pelo menos uma vez ee é executado

----------------------------------------------------------
Hoje terça, setembro 9, 10:52
o uso do switch vem de uma parte se passa o valor e os casos que podem ter de acordo com o valor guardado naquela variavel
lembrar de usar o break pra quebrar o codigo pra proxima linha

tbm da pra usar string pra manipular o for como
        for (String v = "#"; !v.equals("#####");v+="#"){
            System.out.println(v);
        }
aqui se cria uma string v, e equanto a string v for diferente de 5 # ele concatena mais uma # no final e imprime na tela
o break não se usa toda hora, usa-se uma vez ou outra em situações especificas, se nao ele causa má leitura no codigo
evitar principalmente o break rotulado e do continue rotulado, evitar ao maximo pois quebra o entedimento de maneira facil e dinamica do seu codigo

13:30 acabei todos os exercicios do final do modulo de estrutura de repetição
comecei o modulo java poo
até agora :
quando de cria um produto.java, por padrão ele fica dentro de um pacote pra organizar
quando se cria um arquivo .java, dentro desse arquivo se cria automaticamente uma classe com mesmo nome la dentro
public class Produto {}
quando se tem uma classe publica, o nome da classe reflete o nome do arquivo, em lock ou nao tudo igual o nome
dentro de um programa so tem um metodo main, uma classe que tera o metodo main
uma classe define um bloco de codigo
quando se tem public class Produto {bloco de codigo, que aqui dentro vem o metodo main}
uma classe define um bloco de codigo
quando a classe é publica tem a amarração do nome do arquivo com o nome da classe
Classe vs Objeto:
Anatomia de uma classe
modificadores class Nome(convenção CamelCase) variações {

    //corpo

    dentro do corpo da classe temos
    atributos(caracteristicas) e comportamentos(oque tal coisa faz)
    atributos são dados e comportamentos são metodos
    podemos ter dados com estrutura de dados de diversos tipos, como int, boolean, Date, String, Integer
    comportamentos
    no mundo real temos objetos com atributos e comportamentos que podem se relacionar entre si
    uma mae pode ter varios filhos
    um aluno pode fazer varios cursos
    como os objetos interagem e se relacionem entre si ?
    atributos e comportamentos = membros da classe

    dentro de uma unica estrutura posso agrupar atributos e comportamentos

    é uma forma de trazer o mundo real pro software
    uma classe define um tipo - > é uma estrutura de dados personalizada sua

    classe representa uma abstração - simplificação pega o cenario real com todas as complexidades e traz pro sftw de forma simplificada
    a abstração de um produto pra um sftw x pode ser diferente pra outro sftw y, dependendo do grau de complexidade do sftw e produto que voce trabalha
    a classe representa uma simplificação do mundo real

    ja que definimos que a classe é uma estrutura de dados, obviamente uma hora ela vai definir um dado
    esses dados definidos pela classe são os objetos dessa classe
    posso ter varios objetos de uma mesma classe, aonde nao muda a estrutura mas os valores associados aos atributos(caracteristicas)

    objeto são os dados criados apartir da estrutura de dados de uma classe
    entao classe é um tipo e objetos são dados

    objetos = instancia tbm, criei 10 objetos de um tipo produto, entao posso dizer que acabei de instanciar 10 objetos do tipo produto
    instanciar e instancia são sinonimos de objeto
    eu instanciei apartir da classe produto, os objetos soja, arroz e bolacha
    instancia == objeto

   a classe instancia varios objetos, podendo ter varios objetos apartir do mesmo molde
}

se eu tivesse uma classe produto, essa classe teria nome, preço e desconto, 3 atributos, e esses atributos teram tipos
String nome, float preço e int desconto, quando eu crio um objeto apartir dessa classe, os objetos teram os mesmos atributos
notebool, 4.200,15%, todos tem os mesmos dados porque vieram da mesma estrutura de dados

o construtor é um metodo especial, que é responsavel que apartir de uma classe instanciar objetos
o new por exemplo chama o construtor, o construtor é um metodo que apartir de uma classe cria objetos

membros de uma classe 14:19:
classe:
variaveis/constantes
construtor
metodos
classes
dentro de uma classe voce pode definir quantos metodos forem necessarios

nos temos atributos que podem ser de classe ou objeto, e diversas outras coisas que podem ser de classe ou objeto
oque vai diferenciar se um atributo é de classe ou objeto é a palavra static, a palavra static diz que aquela variavel vai pertencer ao objeto, constantes tbm e metodos tbm
adicionando a palavra static voce pode dizer que um objeto pertence a class

acessar os membros...

objeto.membro, se usa a notação ponto para acessar os metodos do objeto, acessando os membros que pertencem a um objeto ou uma classe
apartir do ponto vc consegue acessar seus mebros, seja variavel, metodo
System.out.prinf("")
O print é um membro do out q por sua vez é um mebro do system, notação ponto é a forma que voce tem pra acessar membro de um objeto ou membros de uma classe


metodos:
recebem entradas e saidas
recebem apenas entradas
apenas saida
e nao recebem nem saem

nomeMetodo (metodo camelCase)
tipo que o metodo vai retornar nomeMetodo(); <- nao recebe parametro {
        algoritimos, sequencia de passos;
        retorno do metodo,

      caso um metodo nao retorne nada é void
      nao recebe entrada nem saida
      void nomeMetodo (){}

tipo de retorno nome (parametros de entrada){}
um metodo que recebe dois parametros para somar

//recebe dois parametros de entrada e retorna um parametro
int somarNum (int n1, int n2){
        int resultado = n1 + n2;
       return resultado; voce precisa retornar um inteiro

       nomeMetodo (tipo nome, tipo nome) <- define a identidade do metodo
       pro java oque importa é se os parametros são diferentes, mesmo tendo o mesmo nome
       ele vai diferenciar um metodo do outro pela qntd de parametros

       é mais interessante usar return do que o void que nao retorna nada, porque quando nao tem return ela fica presa ao terminal para funcionar

       construtor voce pode ter mais de um, sendo eles metodos especiais que criam novos objetos
       apartir de uma classe

       quando se cria uma classe chamada produto, essa clase tera um construtor de mesmo nome
       tbm chamado produto nome da classe == nome do construtor
       o construtor padrão java, é o construtor que nao recebe nenhum parametro
                        /////////  <- conhecida como construtor padrão pois nao recebe parametros
       Produto p1 = new Produto ();
       Produto p1 = new Produto (2);

       quando voce define um outro construtor de forma explicita, o construtor padrão n vai existir mais

       class Produto {

       Produto (int a){

       definido construtor de forma explicita, oque distingue um metodo de um construtor é a ausencia de um retorno


       }


       }
       }
}
}
}
}
parei em construtores 16:40 fim do dia

quarta, setembro 10, 10:40

o construtor instancia um objeto, ele inicializa o objeto, entao voce diz o tipo do objeto criado
Produto nome do objeto = new Produto(); <- entao a ordem cria um objeto do tipo produto, aonde o new vai alocar o espaço na memoria para o construtor instanciar o novo objeto
tomar cuidados com as assinaturas de metodo
mesmo sendo dois valores diferentes como
Data(int dia)
Data (int ano) <- as assinaturas são iguais, o java não diferencia o valor, ele olha apenas que sao construtores da classe data, recebendo um unico parametro inteiro, e o java nao sabe diferenciar isso

membros de classe vs instancia:
a classe DAT tem 3 atriibutos
mes
dia
ano
quando eu crio uma nova instancia da data, usando new e o construtor
significa que eu crio uma instancia e essa instancia vao ter alguns espaços
para serem armazenados os valores associados a instancia, significa que para cada novo objeto criado
eu vou ter um espaço em memoria novo pra esses atributos
data new d1 (3,10,2020)
data new d2 (05,06,2006) para cada nova instancia que eu crio, os valores estao associados a instancia
e qual a diferença dos atributos de classe?
se eu vier e dizer que o dia não é mais atributo de instancia
DATA:
static dia <- quando eu uso o static eu digo que o valor do atributo pertence a classe, nao tendo mais um valor dia diferente para cada instancia, estando associado a classe
mes
ano

se eu coloco static dia = 3, todas as instancias teram o mesmo dia 3 associados a elas, pois esse valor foi definido no atributo da classe
antes que o valor era associado individualmente a atributos da instancia, se eu uso o static, esse atributo passa a pertencer a classe
sendo padrão a objetos que vierem a ser desse tipo classe

se precisa instanciar um objeto, pois so depois de instanciado voce pode acessar seus atributos
pra acessar o static, eu posso acessar diretamente pela classe, sem criar uma instancia
sout ("Math.PI"); <- diretamente apartir da classe uso a notação ponto sem precisar instanciar um objeto
em vez de se ter diversas copias associadas a um atributo instanciando objetos
com static voce joga esse valor como uma copia unica para um unico lugar da memoria

valor vs referencia

valor = primitivo
referencia = objetos

quando eu crio uma variavel
int a = 2
em memoria se cria um local chamado a com valor 2
e depois quando vc atribui b = a, é criado outro espaço de memoria
rotulado com o nome b, tendo tbm valor 2, é feito uma copia em memoria
sendo assim uma copia do valor foi atribuida pra b

quando eu crio um objeto Data d1 = new Data();
neste caso se eu fizer
Data d2 = d1; <- tbm vou ter uma area de memoria, e aqui dentro quando crio d1
ele cria uma area de memoria rotulada com o nome da variavel d1, e o valor associado
a essa area de memoria nao vai ser o objeto em si, vai ser o endereço, aonde ele vai apontar
para uma area de memoria aonde de fato tem os valores de dia mes e ano, mas a variavel que tem dentro deka
é o endereço de memoria aonde foi isntanciado o objeto

a atribuição de cima, sao de tipos primitivos, um inteiro a um inteiro
ja quando faço d2 = d1; ele cria outro endereço em memoria com rotulo d2 e copia o mesmo
endereço de memoria de d1, foi feita uma atribuição do endereço de d1, agora d2 aponta pro mesmo
objeto em memoria, isso é uma atribuição feita por referencia, aonde duas variaveis apontam para o mesmo
local em memoria, se d1 alterar x valor desse espaço, d2 ira ver essa alteração e pode modificar tbm

se eu instanciar d2 ele vai apontar para outro objeto em memoria e nao vai mais alterar e nem ver as alterações de d1
quando voce tem um objeto que não é apontado por ninguem, ele vai ser excluido da memoria atraves do coletor lixo java
pois quando ele nao é referenciado por nenhuma variavel, o java joga fora
entao quando voce trabalha com tipos primitivos a associação é por valor
e em objetos é por referencia, aonde elas apontam para o mesmo objeto em memoria

se eu passo um objeto como parametro pra um metodo, esse objeto tbm é passado por referencia
nao passa um clone do objeto, mas uma referencia, e se dentro desse metodo eu mexer nesses dados
quando esse metodo terminar, quem mandou esse objeto vai perceber uma mudança

entao quando eu passo um objeto pra um metodo, ele referencia o endereço do objeto e muda o valor do mesmo
ja com tipos primitivos passados a um metodo , elas duplicam o valor da variavel mas nao altera o valor original


this, sempre que eu quero acessar uma variavel que pertence a uma instancia eu posso usar this.nome da variavel

quando crio uma variavel do tipos int é 0, dos tipos float é 0.0, e boolean é false e do char é '\u000'
valor padrão é dado quando nao se define nada
quando defino uma variavel local e vou usar o valor da variavel a
para imprimir, ela da errp, porque?
variaveis definidas dentro da classe são inicializadas por padrão,
agora variaveis definidas localmente, nao sao inicializados de forma padrao

objetos são inicializados de forma nula
String s = null; ou seja, o objeto s nao aponta pra lugar da memoria nenhum

pra variaveis locais é obrigatorio a inicialização da mesma

valor null:
temos erro de compilação, que nao permite seu codigo nem rodar, de ir pra java pra .class
um erro de codigo, alguma regra da linguagem foi violada
temos erro de tempo de execução, ele compila mas na hora de rodar nao vai

nao posso acessar atributo nem metodo de um objeto nulo, que nao aponta pra nenhum
valor da memoria


capitulo novo array:

array tem um tamanho estatico, fixo, no momento de criação tem que dizer seu tamanho
é uma estrutura unidimensional dividido em x partes, tendo que referenciar alguma variavel
uma vez que eu atribuo um array de tamanho x a uma variavel a, esse tamanho de array nunca vai mudar
ao nao ser que eu crie um novo array maior que o ultimo, e copie todos os dados do ultimo array para esse novo array
assim o aumentando e associando denovo a variavel a

estrutura estatica(tam fixo)
ele é homogeneo, ou seja, se eu dizer que quero um array inteiro, todos os dados guardados la tem que ser inteiros
array é indexado, ou seja pra acessar cada um dos elementos eu acesso apartir de um numerico inteiro, indice
sempre começando no 0 (tam - 1)
o array tbm é um objeto
tendo atributos e comportamentos
int [] a = new int[10] <- acabei de criar um array de tipo inteiro
primeiro eu defino que o vetor é do tipo int, com nome a, chamo o new pra alocar
espaço na memoria, e defino que o vetor de tipo inteiro [tamanho]
a[0] = 1;
como eu armazenei tipos primitivos nao posso usar notação ponto
foreach: é uma estrutura de controle muito usada em controle de arrays e coleçoes
O for-each foi projetado para apenas ler os elementos de um array ou coleção, e não para modificá-los.
Embora tecnicamente seja possível fazer como você fez (alterar o array original dentro do laço),
isso não é uma boa prática e pode levar a resultados inesperados, como você percebeu.

fim dos estudos 16:40 -> for each parei

quinta, setembro 11, 2025

lembrar de usar vetor.length pro laço, é uma forma mais correta de se usar
pra passar por todos os itens do vetor

entendendo equals e hashcode:

quando se tem um objeto do tipo produto
Produto p1 = new Produto();
la na memoria, vou ter uma variavel p1 que vai estar associada e um endereço de memoria e aponta pro objeto instanciado
vamos supor que p1 so tem um atributo e vc cria outro produto p2 da mesma forma
ai vc faz p2.nome = "caneta", exatamente igual ao de cima, porem que aponta pra outro objeto da memoria
tendo os mesmos valores nos atributo

quandi eu faço 2 == 2 é um resultado que da verdadeiro

p1 == p2 é uma expressão false, pq p1 ele aponta pra um endereço de memoria x e p2 aponta pro endereço de memoria y
significa que essa igualdade, igual igual, estamos comparando endereços de memoria
equals ta disponivel em todos os objetos em java

equals

se eu fazer p1.equals(p2); <-falsa, pq o endereço de memoria é diferente, se eu quiser implementar o equals eu crio essa função
e defino o criterio de igualdade

alem do equals tem outra função que eu uso pra implementar
equals vem junto de outra função chamada hashcode
o java tem um conjunto que dentro desse conjunto tem um elemento hashset
o hashcode retorna int, e equals retorna true ou false

se eu tenho um conjunto com varios objetos dentro, e esses conjuntos são baseados em um tipo usuario
ai eu tenho usuarios [ana, bia, lia, cid, luna, luca, lilo] pode ter outros milhares de clientes nesse conjunto
ai se eu quero procurar um elemento chamado bia, obviamente ele ta dentro desse conjunto mas eu nao sei aonde ta
pra eu comparar que um usuario é igual ao outro, eu preciso de um nome e um email. o equals é mais lento
ele compara realmente se um objeto é igual ao outro, e se eu tiver 100 mil usuarios, eu preciso chamar 100 mil vezes
o equals, mas tendo o hashcode, muito mais rapido e separa os elementos que nao sao iguais, pra te dar apenas objetos que tem
a possibilidade de serem iguais
vamos supor que usemos a quantidade de letras do nome pra fazer uma busca mais rapida, se eu selecionar kiko que tem 4 letras
tendo 100.00 elementos nesse conjunto, ele so vai usar o equals dps de separar todos com hashcode igual
vamos supor que ele passou em todos os elementos, ele exclui todos os nomes com menos de 4 letras
e depois usa o equals para comparar com oque eu to buscando, pra comparar de forma mais profunda
sempre que eu implementar um equals tenho que usar o hashcode

instanceof

objeto instanceof Usuarios

o objeto passado é uma instancia de Usuario?

collections, visão geral:
mais pra frente vamos ver o STREAMapi, mas por enquanto vamos ver as bases

diferente do array, as collection tem tamanho variavel, e cresce conforme os objetos adicionados
vantagem gigantesca ao array por exemplo
posso ter colections com dados misturados, nao sendo tao homogeneo como array
embora as boas praticas diz que temos que ter colletctions de mesmo tipo
as colections nao suporta tipo primitivo, tendo que usar um array ou um Wrapper(tipo primitivo envolto de um objeto)

temos algumas collections
collections são uma coleção de coisas dentro de uma estrutura, dependendo do tipo de coleções usadas abaixo
set:
nao ordenado
nao indexado: nao temo como acessar pelo set o elemento pelo indice
nao aceita repeticao:ou seja nao conseguimos colocar dois elementos dentro de um set que sao iguais
list:
indexado: consigo acessar os elementos por indice
aceita repetição: posso por dados repetidos
ordenado
map:
chave/valor (cpf,nome)
chave nao aceita repetição
valor aceita repetição, como se fosse set na chave e list no valor
queue:
implementa fila (fifo)
stack:
implementa a pilha
lifo
se eu quiser adicionar um elemento a qualquer tipo de estrutura de dados acima eu uso add
size pra pegar o tamanho, tendo muitos metodos comuns a diversas collections

Set:
pode ser homogeno (versao melhor)
versao heterogeneo (versao nao ideal)
nao aceita duplicados
pode ser ordenado
nao da pra acessar os elementos por indice
set -> HashSet
size () pra isso e lenght pra objetos
list:
melhor ser homogeneo
aceita obj duplicado
é ordenado
é indexado
fila e mapa;
hash;
------------------------------
sexta, setembro  12, 13:38:
-----------------------------
quando eu penso em uma aplicação grande
essa aplicação é um conjunto de classes q eu vou definir
vou definir varias classes dentro de pacotes diferentes
interagindo entre si
uma dependedno da outra
pra um projeto tao grande, voce normalmente precisa reusar codigos
como se fosse reusar uma parte do codigo ja existente
em cenarios reais vc cria um objeto e uma classe com fucionalidade real pra usar em outras classes
composição:é quando eu tenho um objeto mais complexo e em vez de implementar td dentro de um objeto
eu quebro em objeto menores
um onjeto composto por outros onjetos
se eu tenho um objeto do tipo carro
e esse caro tem relação com o objeto motor
um carro tem um motor, 1 pra 1
se eu tenho um objeto compra e tenho a classe item
eu tenho a relação de uma compra ter varios itens 1 pra n
necessario a ver relacionamentos entre as classes
um ligamento entre as classes signfica que isso é seu sistema
voce so n pode ter um alto acoplamento entre as classes
pois se tiver muitas ligações isso pode grar um efeito em cascata mt grande

                     ------------------------------
                      segunda, 15 setembro 10:56
                     ------------------------------
Reuso via composição
eu tenho uma aplicação, que tem classes dependentes de outras
que tem uma porta de entrada (main), e apartir do main ele chama cada classe
algo muito natural é querer reusar codigo
como calculo de imposto, vocẽ nao quer escrever a logica do calculo toda vez que for usar
voce quer reusar ela de forma mais eficaz, voce cria um objeto e uma classe com funcionalidades
que voce vai reusar no seu sistema

composição:
é uma forma de quebrar o objeto em outros objetos menores
carro, é um sistema complexo, pra isso quebramos ele em partes
portas, rodas, freio, o carro é um objeto agregador que usa outras classes
pra se constituir, sendo composto de outros objetos
tendo o carro, ele tem o motor, cada carro tem um motor 1 pra 1
ja se fosse uma classe compra e uma classe itens
uma compra pode ter varios itens (1 pra muitos)

nao fazer as classes dependerem demais entre si
quanto mais relacionamentos entre as classes, mais dificl é de manter o sistema

Composição é usar outras classes como
atributo de uma classe X,
criando um objeto da classe Y dentro de X
e reutilizando seus métodos depois

relação um pra n

entao a relação de um pra n, é a relação de um pra muitos
se eu tiver uma biblioteca por exemplo
eu crio uma classe livros
e adiciono um arraylist do tipo livros na biblioteca
assim o java ja associa que uma biblioteca tem muitos livros


--------------------------------
terça,setembro 16,10:24:
--------------------------------
n pra n

entao revisando 14:46

um aplicativo são compostas por classes
que ficam dentro de pacotes e interagem entre si
tendo um ponto de entrada(main), uma classe chamando a outra

é necessario reusar algumas partes de codigo, reusando metodos e classes
com funcionalidades reusaveis em outras partes do sistema

tecnica de composição
quando se tem um objeto mais complexo e se quebra ele em partes menores
tenho um carro por exemplo, e pro carro crio o sftw de monitoramento para cada parte dele
e obviamente nao tera uma unica classe que tera tudo do carro de ponta a ponta
a classe carro sera agregadora, tendo outra classe portas, classe rodas, classe motor

carro tem um motor, isso é relação 1:1
compra 1 : n produto, esse n podendo ser um array ou collections, preferivel a collection por ter tamanho nao definido
tio n : n sobrinho
uma relação de composição, um objeto é composto por outros objetos

tomar cuidado para não hiper sociabilizar as classes, tornando as altamente acopladas
pois quanto mais relações entre as classes tiverem, uma mudança gerara mudança em varias partes do sistema

porem é necessario as classes se comunicarem para existir um app
entao apartir do main tem que existir relacionamento entre as classes

relacionamento um pra um

é um relacionamento reuso, porque atraves da relação de uma classe com outra posso associar
elas e reutilizar metodos
como carro e motor
uma classe motor, com seus atributos e metodos, se eu instanciar essa classe na classe carro
o carro passa a se conectar com motor, e a cada carro criado ele tera o seu proprio motor
com acesso a todos os atributos e metodos da classe motor

1 pra n

ja no relacionamento de um pra muitos, uma forma de instanciar isso em java é
tenho uma classe x que tem ligação de muitos com uma classe y
dentro da classe x eu crio um array list de y, ou seja, apartir daquele isntante
x tem varios y(com metodos e atributos cada), uma lista de y

n pra n

a relação de muitos pra muitos é composta de forma
criando um array list de x de y, e criando um array list de y em x
ou seja x tem varios y e y tem varios x
---------------------------------
quarta, setembro 17, 11:26:
---------------------------------
void adicionarCurso (Curso curso){
    this.cursos.add(curso);
    curso.alunos.add(this); // <-- AQUI!
}
então o this se referencia ao objeto que esta chamando o metodo
e passando os parametros, o cursos abre a classe curso dentro da
classe aluno , e adiciona o novo curso que foi dado como parametro
pro metodo, ai depois o curso chama o proprio objeto instanciado
como parametro, acessa a lista de alunos que tem dentro do objeto curso,
e adiciona o proprio objeto que chamou o parametro


eu começo criando meu desafio pela classe produto
package Classe.oo.composicao.DesafioRelacionamentos;

public class Produto {
    final String name;
    final double price;

    Produto (String name, double price){
        this.name = name;
        this.price = price;
    }


} aonde nessa classe temos string nome, definida como final pro nome do meu produto
nunca mudar, e seu preço tbm nunca mudar, crio um construtor produto e diferencio
os atributos do objeto com os parametros passados para construção desse objeto
depois vou pra classe item que tem um relacionamento de produto 1 : 1 item
package Classe.oo.composicao.DesafioRelacionamentos;

public class Item {
    final Produto produto;
    final int qntd;

    Item (Produto produto, int qntd){
        this.produto = new Produto(produto.name, produto.price);
        this.qntd = qntd;
    }
}
aqui eu crio um objeto produto como atributo da classe item, e crio tbm a qntd que vai
ser comprada desse produto
pra criação de uma instancia apartir da classe item, eu uso o construtor item
aonde ele recebe um produto e a qntd como parametro
dentro do construtor eu incializei o produto do objeto classe apartir dos atributos do produto passado
como parametro e depois vou pra classe compra onde fica nossa regra de negocio
package Classe.oo.composicao.DesafioRelacionamentos;

import java.util.ArrayList;

public class Compra {
    final ArrayList <Item> itens = new ArrayList<>();


    void adicionarItem (Produto p, int qntd){
        Item it = new Item(p,qntd);
        itens.add(it);
        System.out.println("item adicionado com sucesso!!");
    } nessa função eu crio um objeto da classe item e inicializo ele com os parametros
    passados no metodo, ou seja, crio um objeto item, que recebe os parametros passados a eke
    inicializa eles na memoria atraves do construtor, depois do objeto item criado com o produto
    e qntd eu insiro entao ele na lista e depois retorno uma mensagem de sucesso

    double getValorTotal (){
        double total = 0;

        for (Item it : itens){

            total += it.qntd * it.produto.price;

        } aqui eu somo o valor total dos itens que o cliente quer comprar, se
        ele comprar uma bala de 2 reais e comprar 3 balas ele multiplica o 2 * 3 e
        guarda no total, retornando essa variavel

        return total;
    }

}
compra tem uma relalação de n:1 com item ou seja, uma compra pode ter varios itens
entao eu crio uma lista de itens dentro da classe compra
package Classe.oo.composicao.DesafioRelacionamentos;

import java.util.ArrayList;

public class Cliente {
    final String nome;
    final ArrayList <Compra> compras = new ArrayList<>();


    Cliente (String nome){
        this.nome = nome;
    }diferencio atributo e parametro


    void adicionarCompra (Compra compra){
        this.compras.add(compra);
    } digo que this(o objeto pessoa que chamar) vai abrir a lista de compras dele
    e adicionar a nova compra passada como parametro

    double getvalorTotalCli (){

        double soma = 0;

        for (Compra cmp : compras){
            soma += cmp.getValorTotal();
        } aqui eu somo o valor todas de todos os itens do usuario

        return soma;
    }
}
a classe cliente tem uma ligação de um cliente pode fazer varias compras, entao tem
uma lista de compras nos atributos de cliente, alem de seu nome

Paradigmas de programação:

formas criadas de como estruturar os pensaemtos e ideias para pegar algo do
mundo real e transformar isso em sftw
nao estruturados, tipo o go to, aonde vc tinha um bloco de codigl
e coloca go to e ele ia pra outro bloco, e depois pra outro
programação macarronica, ou seja não estruturado
procedural:
define um procedimento, um conjunto de sentenças agrupadas(função) e ali coloco
uma sequencia de passos, dijkstra cria o paradigma procedural, lida com dados mutaveis
globais, funções
funcional
é um paradigma q se da bem com processamentos paralelos , pois trabalha muito
com constantes, embora o java seja centrada em oo, o funcional começou a ser introdu
zido em java
diferença do procedural pra oo
no procedural o foco é a função, sendo a mesma q altera os dados
ja oo tem o foco no dado, aonde a classe define uma estrutura de dados
aonde o objeto instanciado, o foco é o dado, o tem tem comportamentos

procedural vs oo
ator principal do procedural é a função, crio funções que recebm paremtros e mudam valores
ja na oo o ator principal é o objeto, eu tenho um objeto onde apartir dele
eu mexo em atributos e comportamentos

formatarData (nascimento) eu tenho uma função que repasso o dado pra ela
ja na oo
eu tenho um objeto
o dado, aonde dentro dele eu tenho um metodo associado a esse dado
nascimento.formatarData();
classes definem tipos
em java eu tenho que criar funções(metodos dentro de classe)
ja no procedural eu crio funções soltas

a maioria das linguagens são ditas multiparadigmas, pq trabalham cm todos esses
paradigmas, como js,python
paragima é como eu organizo minha mente para aplicar isso no codigo
tendo cada paradigma seus principios, e se vc seguir os principios seu
codigo vai ter uma qualidade melhor

Principios de POO:

Princípios de POO (Versão Corrigida)

1. Encapsulamento

O encapsulamento diz que parte da complexidade de um objeto deve estar escondida
para o mundo exterior. Como em um carro: ele tem pedais, volante e banco.
Você interage com tudo isso, porém, não sabe o que há no motor,
mas consegue usar o carro através da sua interface de comunicação,
não precisando conhecer os detalhes internos de um objeto para usá-lo.

2. Herança

É um tipo de reuso de código. Enquanto na composição a relação é de "tem um",
na herança a relação é de "é um": um Celta é um carro, um Civic é um carro.

3. Polimorfismo

É a capacidade de usar um conceito genérico para tratar de coisas específicas.
Posso criar no meu sistema, por exemplo, um atributo do tipo Animal e associar
diferentes tipos de animais a esse atributo. Para entender isso, é preciso
saber de Herança.

4. Abstração

Quando vou desenvolver um sistema, observo o mundo real e simplifico sua
complexidade, escrevendo um software de acordo com o que foi pedido.
Nem tudo que existe no mundo real estará presente no meu software.



A Filosofia do Encapsulamento

O encapsulamento esconde a complexidade e expõe a funcionalidade.
Na vida real, ele tem diversas aplicações, como encapsular as partes
sensíveis de um PC: processador, RAM, HD. Você não precisa saber como
o Sistema Operacional (SO) controla os processos para usá-los;
você apenas os utiliza através de interfaces de comunicação.

Algo estar private em Java significa que está escondido.
Em um carro, a direção e a marcha estão públicas,
porém o motor está privado. Não é preciso ter acesso ou
entender como ele funciona; você só acessa o que é público.

Encapsulamento e Dependências

Quando se tem um alto grau de dependência entre as coisas, isso
significa um baixo nível de encapsulamento. Quanto menos eu
exponho para o usuário (outras partes do código),
menor a chance de haver problemas nos relacionamentos.

O encapsulamento é como uma cápsula. Ele agrupa os atributos e
métodos de um objeto. O fato de agrupá-los me dá a chance de
encapsular melhor as coisas. Ao colocar o dado perto do
método que o utiliza, é possível que aquele dado não precise
mais ser visto pelo resto do sistema, garantindo sua integridade e
obtendo uma segurança maior.

Modificadores de Acesso

    private (o mais privado possível)

    package (padrão/default)

    protected

    public

private e public

Quando eu defino uma classe e crio um atributo do tipo private,
ele só pode ser acessado de dentro da própria classe, não sendo possível
acessá-lo em outras classes.

Para permitir a interação, eu defino um método público (visível)
que, por sua vez, acessa o atributo privado. Assim, outra classe
pode chamar o método público para interagir com o dado, que permanece protegido.

Agora, no extremo oposto, se eu crio uma classe ou método public,
qualquer lugar do meu sistema pode acessá-lo.

package e protected

Um membro com acesso package (padrão, sem modificador) só é acessível por
classes que estão dentro do mesmo pacote. Por padrão, se nenhum modificador
for especificado, o acesso é de nível package.

Um membro protected é visível na própria classe, em todo o pacote e
também é transmitido por herança para subclasses, mesmo que elas estejam em
outros pacotes.

Herança:

outra forma de reuso, começamos o capitulo falando de composição, aonde uma
classe colabora com a outra relaçoes n pra n, 1 pra n, 1 pra 1, uni e bi
direcionais, porem o reuso via composição sempre sera mais flexivel que a herança
por via de regra se reusa codigo apartir de composição (priorizado)

usar herança pode ajudar, mas usar de forma exagerada ou ter muitas hierarquias n
é bom

composição tem um
carro tem um motor
carro tem portas
casa tem cozinha
herança é
civic é um carro
gato é um animal
maçã é uma fruta

por padrão definimos se vai ser composição ou herança atraves dessas palavras
sendo mais encontrada composição do q herança no dia a dia

na composição eu tenho uma ref pra aquilo que vou usar
dentro de carro tenho um onjeto motor criado por exemplo

no caso de herança é um outro mecanismo pra reutilizar um codigo
exemplo herança
eu crio uma classe mais generica chamada carro
crio outra mais especifica chamado civic e civic herda comportamentos de carro
animal (mais generico) e apartir do momento que vou descendo na hierarquia vai ficandp
mais especifico
animal
é um mamimefro
é um mamifero aquatico
é um mamifero terreste
quanto mais generico é o conceito, menos coisa ela deve fazer, encontrar comportamentos
que sao comuns a todos os animais
sendo a classe mais baixa da arvore recebendo todos os comportamentos das classes de cima
quanto mais especifico eu vou ficando, mais comportamentos eu vou agregando de todos o pais

superclasse (classe mais generica) quanto mais a cima na hierarquia menos comprotamento
comportamento precisa estar presente em todas as outras subclasses

subclasse
+especifica

uma classe pode no momento ser uma super classe ou subclasse

hierarquia nem toda gera herança
soldado
cabo
sgt
sub
capitao
aqui temos uma hierarquia, mas nao uma que gere herança, nem tudo que representa
é um eu vou querer mapear com herança
alguns padroes te ajudam a substituir composição por herança, pq composição fica
mais flexivel que herança um desses padroes mais famosos é o decorator

isso n ocorre em todas as linguagens, pois algumas linguagens tem heranças multiplas

uma classe em java só pode herdar de uma classe, posso ter outras classes herdando de uma
mesma classe

uma classe só herda de uma classe

algumas linguagem permitem heranças multiplas, aonde uma unica classe pode herdar
de outras classes

isso ocorre em c++ exemplo

receber por padrão comportamentos e atributos sem precisar definir eles na sua classe

eu tenho uma classe que herda a classe de cima, atributos e metodos
por padrão acabo recebendo esses atributos e comportamentos
eventualmente vou ter atributos ou comportamentos que nao vou querer receber
de herança exatamente como foi definido na classe pai, so q vamos supor se eu quero
mudar ou especificar esse metodo, eu posso reescrever esse metodo
é possivel eu reescrever esse metodo na subclasse e apontar pra implementação original
e complementar com algumas coisas, mas quando n faço nada, e so digo q algo herda de outra
classe, eu recebo por padrão os comportamentos

extends diz que uma classe herda de outra classe


polimorfismo(multiplas formas):
temos dois tipos
estatico(sobrecarga) e dinamico

imagine que eu tenho uma classe, e dentro dela, podemos criar metodos com o mesmo
nome, divergindo apenas na sua assinatura, a qntd dos parametros influencia, tipo tbm
qnd eu tenho varios metodos com o mesmo nome, eu sobrecarrego aquele nome

opa()
opa(--)
eu tenho varios metodos com o mesmo nome com a assinatura dele diferente
é um polimorfismo estatico, pq eu escrevo ele, multiplas formas diferentes
de usar o metodo opa, estatico pq eu escrevi esse metodo

o outro tipo, é dinamico
pra eu ter um dinamico, um pre requisito pra isso acontecer, eu preciso
ter herança

carro -> civic
carro -> ferrari
Nome da classe
Civic c = new Civic(); ->construtor, exatamente o mesmo nome
Carro c = new Civic(); ou seja, eu instanciei um carro especifico e atribui a uma classe
mais generica,
polimorfisco acontece quandi eu instancio uma variavel c, e posso atribuir uma ferrari
sendo ele do tipo generico carro, podendo tomar a forma de outros objetos e formas desde
q seja subclasses da classe pai que foi instanciada
do tipo mais especifico pro tipo mais generico, sendo ao contrario nao verdadeiro

outro exemplo, pode ser no metodo,
um metodo q receba um civic, eu posso passar uma ferrari pra la ? n
mas eu posso criar um parametro mais generico, recebendo um carro
nao mais um civic, podendo passar todos os tipos de carro

abstração é quando simplifico algo do mundo real e colocar dentro do sftw
espelhar o mundo real em sftw
nem tudo que esta no mundo real da pra por no sftw
nem tudo do sftw se aplica na vida real
faz parte como desenvolvedor, perguntar questioner e interrogar o cliente pra entender
sua necessidade

=============================
quinta, setembro 18, 12:30:
=============================
Enum outro tipo de estrutura alem da classe q posso ter em java


antes de criar um enum eu poderia passar uma string como parametro
a desvantagem disso é saber exatamente o tipo de dado q vc quer passar
precisa mapear e n torna o codigo simples
|
\/
boolean andar (String direcao){

        if ("norte".equalsIgnoreCase(direcao)){
            y++;
        }
        return true;
    }

    como eu posso substituir esse parametro pra algo mais interessante
    usar uma enumeração serve pra quando vc tem uma qntd definida de possibilidades
    dias da semana, meses do ano, qndt determinada de opcçoes
    norte, sul, leste e oeste
    da pra criar um enum que represente isso


    nós podemos definir mais de um construtor dentro de uma classe.
    Ele recebe parâmetros, diferenciando sua assinatura.

    Dentro de um construtor, quando se usa um this como método,
    posso chamar um construtor através de outro construtor.
    O que não pode acontecer é, a partir do último construtor,
    chamar o primeiro construtor de novo, pois senão vira um ciclo
    sem nunca criar o objeto. Então, um desses construtores tem que
    terminar a construção.

    Tendo duas classes, uma subclasse e superclasse,
    dentro da subclasse eu defino 2 construtores: um padrão e
    outro normal. Vamos supor que, a partir do construtor padrão,
    eu chamei o construtor da classe atual. Pelo menos um desses
    construtores vai chamar um construtor da classe pai com super.

    super é a referência do objeto que representa a classe pai.
    Também posso chamá-lo como um método. A partir do momento que eu
    zero os construtores da subclasse, ele chama um construtor da superclasse.

    Quando eu tenho uma classe, ela vem com um padrão, com uma única
    chamada dentro dele, um construtor padrão, que é chamar o construtor
    padrão da classe pai. E se na classe pai não tiver um construtor padrão?
    Aí você precisa chamar o construtor de forma explícita.

    quando eu coloco classes juntas dentro de um pacote, isso tem um significado
    importante do ponto de vista de encapsulamento, signfica que a uma comunicação
    mais intima entre essas classes, se eu tenho um package rh, acreditase que por
    padrão, as classes que estao dentro de um mesmo pacote, tem um nivel de comunica
    ção maior do que outras classes que estao fora desse pacote


  Sexta, setembro 19, 12:00:

    estando dentro de um mesmo pacote, uma classe a, consegue ver default, protected
    public de uma classe b, menos o private

    ja duas classes que nao estao dentro de um pacote, supondo que uma classe a
    gerou por herança uma classe b, essa classe b tem acesso as informações protected
    de a, vendo protected(recebe por herança) e public

    quando eu sobreescrevo um metodo, eu n posso diminuir seu nivel de visibilade
    ou mantenho ou aumento seu nivel

    uma classe só pode ser do tipo public ou package

    getters/setters
    quando eu crio atributos dentro de uma classe, via de regra quando sao atributos
    variaveis, eu crio get e set pra acessar essas variaveis private

       get e set te ajudam no encapsulamento do projeto, pegando atributos privados e permitindo
       os modificar apartir de uma validação que ocorre em metodos dentro da propria classe
       nao deixando o usuario saber de toda a complexidade do sistema

       set = modificiar um elemento
       get = pegar um elemento



segunda, setembro 22, 13:43

public abstract, é um metodo que n tem corpo
todos os metodos dentro de uma interface sao metodos abstratos
Enum: É uma lista de VALORES fixos.
É sobre "o que algo É" (ex: o dia É SEXTA).

Interface: É uma lista de AÇÕES obrigatórias.
É sobre "o que algo FAZ" (ex: um carro FAZ a ação de acelerar).

classe abstrata:

classe concreta <---------------------> interface
tenho um conceito abstrato chamado mouse, e um conceito concreto que é o mouse mesmo fisico
embora ele atenda a requisitos abstratos'
uma classe concreta é uma classe aonde todos os metodos tem corpo

uma interface é uma estrutura que tem metodos, mas n define o corpo do metodo
a interface tem 0 dos metodos implementados, ficando pra ser modificado em cada classe
que implementa a interface, sendo modificada individualmente

classe abstrata, ela mescla as duas classes, podendo ter todos os metodos definidios
alguns sim e outros não, ou n ter nenhum metodo concreto

uma classe abstrata n pode ser instanciada

public abstract class pessoa {
apartir do momento que uso a palavra abtract eu n posso mais instanciar um objeto
}
}

quero criar uma classe abstrata qnd tenho herança. n faz sentido criar uma classe abstrata
que n vai ser herdada

o conceito cachorro é algo abstrato, ja um cachorro especifico é algo concreto

inicio do curso do guanabara POO

======================================================================================
aula 1 :
origem da poo
tem o objetivo de aproximar o mundo digital do mundo real
antigamente se programava em baixo nivel, todas as intruções eram dadas
ao pc da forma q ele entendia, binario,decimal e etc
depende da programação dos computadores

essa modalidade de linguagem de maquina era muito dificil e trabalhoso

depois surgiu as linguagens de alto nivel (programação linear)
de cima pra baixo, sem desvios e sem rotinas internas
dava instrução de cima pra baixo com se fosse uma lista de compras

programação estruturada. permitia pequenos pedaçõs de programação linear,
tomar caminhos diferentes

precisou se criar de programa modular, permitia criar pequenos modulos estruturados
que podem compor sistemas maiores e maiores

surgiu outro paradigma, que surgiu com base no modular, o poo

então tudo começa nas linguagens de baixo nivel

quem criou poo?
aln kay, n era um dev, ele é formado em matematica e biologia
ele gostava de relacionar as duas areas
gostava de educar
principalmente crianças

ele foi trabalhar na xerox, ele estava envolvido em diversas criações tecnologicas

uma das criações dele foi o dynabook
teria uma tela, um teclado, e apartir da iteratividade as crianças poderiam aprender
o alan key, tbm é considerado um dos pais do notebook
todos os conceitos que ele criou são muito importantes
uma das tecnologias que ele teve que criar ora usar o dyna, é uma linguagem de programação
ele cria o smalltalk, primeira linguagem de programação orientada a objetos

smalltalk ja tinha classe, objeto, atributos e metodos

vantagens:
no padrão são 6
comern
c-confiável (isolamento entre as partes, gera sftw seguro, ao alterar
uma parte, nenhuma outra é afetada)
o-oportuno (ao dividir tudo em partes, varias partes podem ser desenvolvidas
em paralelo)
m-manutenivel (atualizar um sftw é mais facil, uma pequena modificação vai
beneficiar todas as pertes que usarem o objeto)
e-extensivel(sftw n é estatico, deve crescer pra se manter util)
r-reutilizavel(podemos usar objetos de um sistema que criamos em outro objeto futuro)
n-natural (uma coisa natural é algo mais facil de entender,
+funcionalidade -implementação)
aula 3:

mudando a visibilidade

linguagem de modelagem unificada
uml (preciso estudar diagrama de classes)
caneta é um objeto, na hora de criar um molde pra caneta
se cria uma uml
retangulo (classe)
no topo do retangulo se coloca o nome da classe
----------------------------
           caneta
----------------------------
caracteriscticas (atributos)
----------------------------
           metodos
----------------------------

são 3 modificadores de visibilidade em java:
indica o nivel de acesso aos componentes internos de uma classe
podendo utilizar 3 simbolos pra isso + - #
+ public
- private
# protected

terça, setembro 23, 11:06:

Metodos especiais:
e = nova estante();

atributos da estante:
cor
tipo da madeira
tamanho
prateleira
portas
modelo
--------------------
abrir();
fechar();
colocar();
retirar();

t = e.totDoc = ele acessa o atributo atraves da notação ponto do objeto instancionado

metodos acessores:
dão acesso a uma determinada coisa
getters ( metodo que vc pega algo, acessa algo, alguma informação)
serve pra ser mais confiavel a manipulação de dados

voce usa os metodos getter e setters para acessar e modificar atributos do objeto
sejam eles privados ou não, tudo passaria no get e no set antes de chegar no final

vc nao deixxa o objeto acessar direto o dado, sim chama uma função, que seria uma pessoa
que tem acesso a chegar nesses dados, ele pergunta pra essa pessoa, e solicita a execução
de um determinado metodo

existem formas de dar acesso a um determinado atributo, sem dar acesso direto ao determinado
atributo
metodos acessores (getters consegue acessar atributos mantendo a segurança dos dados)
metodos modificadores(setters)
nao permite que os usuarios acessem os atributos de forma livre, e sim de uma
forma segura e controlada, vc passa algo pro metodo, dentro do metodo ele tem
acesso a modificação dos dados

setter precisa de um parametro para funcionar
precisa receber um documento, para por o documento na estante
ter get e set de cada atributos


metodo construct
ele serve pra criar e alocar espaço em memoria de forma a criar um objeto
com padroes definidos, Alocar espaço na memória para o novo objeto

Inicializar atributos com
valores padrão
ou personalizados
Executar lógica
de configuração necessária para o
objeto funcionar corretamente

Quarta, setembro 24, 11:07:

encapsulamento
ele ajuda a proteger a integridade e funcionamento dos dados e metodos
ajuda a padronizar o sistema, vc n precisa saber da complexidade de um sistema
pra usa-lo, pois muitas vzs vc pode mexer e acabar interferindo em partes sensiveis
e alterando tudo, protege o codigo do usuario e o usuario do codigo
um codigo encapsulado usa interfaces e moldes padrão

Encapsular não é obrigatorio, mas uma boa pratica para produzir classes mais eficientes

vantagens:
tornar mudanças invisiveis
facilitar reutilização do codigo
reduzir efeitos colaterais

quando eu uso getters e setters privados, eu forço
o usuario a utilizar meu codigo apenas pelos metodos
da interface, n tem como algum usuario chegar e settar
que o som é 100, n ele tem que chamar o metodo publico aumentar volume
passa o volume, dentro da classe publica se faz as validações necessarias
usando get e setters, ai sim aumentando o volume
deixando tudo mais seguro

o private, ele diz que aqueles atributos ou metodo só podem ser acessados
apartir daquela classe
public qualquer classe pode acessar os atributos e metodos publics e utilizar ela

todos os atributos vão ter visibilidade privada, pois estão incapsulados
eles só vão poder ser modificados apartir dos metodos publicos disponibilizados pela
classe

quinta, setembro 25, 14:52

uma interface em java então, eu crio quando eu tenho metodos que n sei
como vou implementar, mas sei que vou precisar implementar eles, quando
eu coloco que uma classe inclui uma interface, eu preciso colocar todos
os metodos abstratos que estão dentro dela, na classe, e pra cada classe
que essa interface incluir vai precisar aplicar esses metodos abstratos
que foram definido na interface, porem de forma individual pode ser feita
a maneira de funcionamento desses metodos

encapsulamento em poo, é quando eu escondo toda a complexidade do meu projeto,
disponibilizando apenas os metodos necessarios para que o usuario utilize meu
codigo de forma segura, permitindo que mudanças futuras sejam mais faceis de
fazer e tornando o codigo mais seguro, pq uma vez q o usuario precisa usar um
getter ou setters pra acessar meus atributos privados e dentro desses getters
e setters tenho varias validações, fica mais seguro

nao preciso seguir a risca os getters e setters, posso adaptalos aos meus ecercicios

uma agregação é quando um objeto tem um outro ombjeto, reuso via composição

é melhor atribuir valor a um objeto dentro de um construtor apartir dos metodos
setters, pois la eles tem melhor validação

eu consigo ligar uma classe com a outra
existem varias formas de relacionamento
mas veremos agora a agregação

ou seja, consigo criar um objeto lutador dentro da classe luta
ou seja um objeto lutador passa a ser um atributo da classe luta
e pra instanciar um objeto luta eu preciso passar um lutador para o
construtor

1 lutador pode participar de varias lutas
uma luta pode ter varios lutadores


Sexta, setembro 26, 14:39
revisão da materia de encapsulamento e reuso via composição
Segunda, setembro 29
estudei para a prova do dodo, sai um pouco de java


terça, setembro 30, 12:26:
Herança:
uma subclasse pode puxar caracteristicas e comportamentos de superclasses(classe pai)
vc tem uma classe mais generica que vai ser pai de outras classes mais especificas
voce aprimora os conceitos (fica mais especifico) a cada subclasse

*depois dar uma revisada em relação bidirecional*

